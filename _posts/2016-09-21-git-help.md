---
layout: post
title: "Git 常用命令 和 分支详析"
categories: Git
tags: Git
---

* content
{:toc}

概述
===
git 是一个流行的开源的分布式版本控制系统。包含了150多个子命令，常用的只有 30 个左右。下面
首先按照常见的开发工作流介绍 git 在日常工作中的可能使用到的命令以及一些极有帮助的选项。然后
较为详细地介绍了 git 的必杀特技：**引用和分支**。




git 的日常使用
=============
下面是 git 在日常使用过程中最有可能用到的命令以及选项

克隆或者新建仓库
--------------
+ `git clone <repo-url>`
+ `git clone -b <name>` : 检出 name 分支，而不是默认的 master
+ `git init`

配置
--------
git 的配置分为三个等级：system，global 和 local，分别代表系统级配置，用户全局配置，仓库
独立的配置。优先级递增。高优先级的配置会重载低优先级的配置。这三个等级的配置分别通过指定 
`--system`， `--global` 和 `--local` 选项进行设定。

+ `git config --global user.name <your-name>`
+ `git config --global user.email <your-email>`     
+ `git config --global alias.st status`
+ `git config --global alias.graph "log --graph --oneline --all --decorate"`
+ `git config --global core.editor vim`
+ `git config --global core.fileMode false`
+ `git config --list`

前两项配置 git 的用户名和邮箱地址，当大家用同一账号工作于同一主机的时候，不要指定 
global选项，否则在你提交代码的时候，你的工作成果就成了别人的，或者别人的工作成果成了你的。
应该进入你的仓库，在设置的时候指定 local 选项： `git config --local ...`

跟踪文件、添加修改、检查状态与提交
---------------------
+ `git add <path>`
+ `git add .`
+ `git status`
+ `git commit`
+ `git commit -a`：跳过添加到暂存区的步骤，直接提交
+ `git commit -v`：在提交时显示详细（统一 diff 格式）的文件变化信息
+ `git commit -m <message>`
+ `git commit --amend`：修订提交
+ `git commit --amend --reset-author`：修改提交者信息

检查修改
-------
+ `git diff`：对比工作区与暂存区
+ `git diff --staged | --cached`：对比暂存区与仓库
+ `git diff <commit>`：对比工作区和某一次提交
+ `git diff <path> <path>`：对比两个文件
+ `git diff <commit> <commit> [path...]`：对比两次提交

查看提交日志
-------
+ `git log [path...]`
+ `git log -p -n [path...]`：显示最新的 n 次提交，并列出详细的对比
+ `git log --pretty=fuller`
+ `git log --oneline --graph --decorate --all`
+ `git log --author=<pattern> --committer=<pattern>`
+ `git log --after=<date> --before=<date>`
+ `git log --grep=<pattern>`

移除、移动文件
-------
+ `git rm <file>...`
+ `git mv <src>... <dst>`

撤销操作
-------
+ `git checkout -- <file>...`：取消工作区文件的修改
+ `git reset HEAD <path>...`：取消暂存
+ `git reset --soft <commit>`：重置当前分支指向某次 commit
+ `git reset --mixed <commit>`：并重置暂存区
+ `git reset --hard <commit>`：并重置工作区

远程仓库
-------
+ `git remote -v`：显示远程仓库
+ `git remote show <remote-name>`：显示远程仓库的所有引用
+ `git ls-remote -h -t`：同上
+ `git fetch <remote-repo> <branch-name>` 
+ `git push <remote-repo> <src>:<dst>`
+ `git pull <remote-repo>`

分支
---
+ `git branch [-r] [-a]`：列出本地分支，远程跟踪分支，所有分支
+ `git branch <branch-name>`：创建分支
+ `git checkout <branch-name>`：切换分支
+ `git checkout -b <branch-name> [start-point]`：新建分支并切换
+ `git branch --track <branch-name> [start-point]`：创建分支并跟踪远程分支
+ `git checkout -b <branch-name> --track <remote>/<branch-name>` 
+ `git branch --set-upstream-to=<upstream> [branch-name]`：设置跟踪分支
+ `git push origin --delete branch-name`：删除远程分支
+ `git merge <branch-name>`

打标签
-----
+ `git tag`
+ `git tag -l <pattern>`：列出
+ `git tag -a -m <message> <tag-name> [commit]`：打 tag
+ `git tag -d <tagname>...`： 删除

gerrit 代码提交 sop
------------------
1. `git clone ssh://YOU-ACCOUNT@10.195.229.38:29418/QC/platform/frameworks/av`
2. `git checkout -b C5F/dev/MSM89xx/04710/PFAM --track origin/C5F/dev/MSM89xx/04710/PFAM`
   
    这一步是在本地新建一个工作分支跟踪远程分支并检出。其实，前两步可以合并为：
    `git clone ssh://YOU-ACCOUNT@10.195.229.38:29418/QC/platform/frameworks/av`
    ` -b C5F/dev/MSM89xx/04710/PFAM`。分两步走可以让我们更加清楚自己在干什么。
   
3. 修改代码
4. `git add; git commit`：添加修改并提交
5. `git push origin HEAD:refs/for/C5F/dev/MSM89xx/04710/PFAM`：推送到远程并等待审核

为什么要加 `refs/for/`？

根据 git 的语法，就上面的例子而言，将本地分支的最新修改推送到远程仓库，需要这样做：
`git push origin HEAD:C5F/dev/MSM89xx/04710/PFAM`，但是对于 gerrit 来说，必须加上 
`refs/for/`，这是 gerrit 的特殊语法，加上 `refs/for/` 之后，实际推送过去的分支并没有
合并，而是处于等待 review 的状态。

可以在 [这里](http://10.195.229.38/Documentation/user-upload.html) 找到关于 gerrit 
提交代码的详细资料。


忽略文件
-------
一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些
自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建
一个名为 .gitignore 的文件，列出要忽略的文件模式。 来看一个实际的例子：

    $ cat .gitignore
    *.[oa]
    *~
    
第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中
出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都
用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的
文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。

文件 .gitignore 的格式规范如下：

+ 所有空行或者以 ＃ 开头的行都会被 Git 忽略。
+ 可以使用标准的 glob 模式匹配。
+ 匹配模式可以以（/）开头防止递归。
+ 匹配模式可以以（/）结尾指定目录。
+ 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。

git 引用
========
git 中的HEAD指针，分支，标签，都是引用。引用其实就是一个包含了 SHA-1 值的文件。所谓引用
引用的就是 40 个字节的 SHA-1 值。

我们可以借助类似于 `git log 1a410e` 这样的命令来浏览完整的提交历史，但为了能遍历那段历史
从而找到所有相关对象，你仍须记住 1a410e 是最后一个提交。 我们需要一个文件来保存 SHA-1 值，
并给文件起一个简单的名字，然后用这个名字指针来替代原始的 SHA-1 值。

在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在 .git/refs 
目录下找到这类含有 SHA-1 值的文件。

    $ tree -CF .git/refs/
    .git/refs/
    ├── heads/
    │   ├── master
    │   └── new
    ├── remotes/
    │   └── origin/
    │       └── HEAD
    └── tags/

分支
-------
git 分支其实只是 `.git/refs/heads` 目录下面的一个包含了 40 个字符提交ID的文件。只使用 
40 个字节的提交ID，同样可以实现分支的功能。但是 40 个字节的 ID 不好记忆。因此 git 通过
`.git/refs/heads/` 目录下的引用文件来方便的实现分支功能。下面尝试通过手动在 
`.git/refs/heads/` 目录下面新建一个文件来创建一个分支：

![](git-help-images/create-branch.png)

然后尝试在该分支上提交几次代码，看手动创建的分支是否可用：

![](git-help-images/commit.png)

可见 手动创建的分支跟 `git branch ` 命令创建的分支是一样的。当运行类似于 
`git branch (branchname)` 这样的命令时，Git 实际上会执行相同的操作，取得当前所在分支
最新提交对应的 SHA-1 值，并将其写入 `.git/refs/heads` 目录下面的一个文件中。

HEAD 引用
--------
现在的问题是，当你执行 git branch (branchname) 时，Git 如何知道最新提交的 SHA-1 值呢？ 
答案是 HEAD 文件。

HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，意味着
它并不像普通引用那样包含一个 SHA-1 值——它是一个指向其他引用的指针。 如果查看 HEAD 文件的
内容，一般而言我们看到的类似这样：

    $ cat .git/HEAD
    ref: refs/heads/master

如果执行 git checkout test，Git 会像这样更新 HEAD 文件：

    $ cat .git/HEAD
    ref: refs/heads/test

当我们执行 git commit 时，该命令会创建一个提交对象，并用 HEAD 文件中那个引用所指向的 
SHA-1 值设置其父提交字段。

远程跟踪分支
----------
如果你添加了一个远程版本库，并对其执行过推送操作，Git 会记录下最近一次推送操作时每一个分支
所对应的值，并保存在 `refs/remotes` 目录下。 如下 git 仓库中 refs/remotes/origin 目录
下面的文件即为**远程跟踪分支**，远程跟踪分支可以使用 `git branch -r` 查看。

    $ tree -C .git/refs/
    .git/refs/
    ├── heads
    │   ├── master
    │   ├── new
    │   └── test
    ├── remotes
    │   └── origin
    │       ├── HEAD
    │       ├── new
    │       └── test
    └── tags


远程跟踪分支和本地分支（位于 refs/heads 目录下的引用）之间最主要的区别在于，
**远程跟踪分支是只读的**。虽然可以 git checkout 到某个远程跟踪分支，但是 Git 并不会将 
HEAD 引用指向该远程跟踪分支。因此，你永远不能通过 commit 命令来更新远程跟踪分支，他们只能
由和远程服务器交互的命令（如 `git fetch`）来自动更新。 Git 将这些引用（远程跟踪分支）作
为记录远程服务器上各分支最后已知位置状态的书签来管理。

![](git-help-images/remote-ref.png)

从上图可以看出虽然检出了远程跟踪分支，但是 HEAD 处于分离头指针的状态，因此不能在此处进行
开发。必须检出本地分支才可以进行开发。

分支（本地分支）和远程跟踪分支的关系
---------------------
clone 一个项目之后，git 会为远程仓库中的所有分支都在本地创建对应的远程跟踪分支，然后创建
一个初始化分支（也即本地分支，一般 fork 自远程仓库的 master 分支），并检出该分支的代码。
如果我们想在其他分支上（非 master）工作，就必须首先创建并检出该远程跟踪分支对应的本地分支。

首先我们 clone 一个仓库：

    git clone ssh://H2404689@10.195.229.38:29418/QC/platform/frameworks/av
    
clone 之后，git 为我们在本地创建了所有的远程跟踪分支（只读的）：

    $ git branch -r
    origin/B5F/dev/MSM8953/00310/PFAM
    origin/B5F/dev/MSM8953/00910/PFAM
    origin/B5F/dev/MSM8953/01410/PFAM
    origin/C5F/dev/MSM89xx/02910/PFAM
    origin/C5F/dev/MSM89xx/04710/PFAM
    origin/C5F/dev/MSM89xx/05610/PFAM
    origin/C5F/dev/MSM89xx/06010/PFAM
    origin/C5F/dev/MSM89xx/V2.20A/P2
    origin/C5F/dev/MSM89xx/V2.21A/CTA
    origin/C5F/dev/MSM89xx/V2.22A/P1
    origin/C5F/dev/MSM89xx/V3.38A/FTM
    origin/HEAD -> origin/master
    origin/QC/MSM8953/00310
    origin/QC/MSM8953/00910
    origin/QC/MSM8953/01410
    origin/QC/MSM89xx/02910
    origin/QC/MSM89xx/04710
    origin/QC/MSM89xx/05610
    origin/QC/MSM89xx/06010
    origin/master

然后创建了一个本地分支 master 并检出代码。
    
    $ git branch
    master

但是我们检查当前工作目录中却没有文件，这是因为，该仓库的 master分支上面没有提交代码。

如果你要在 C5F/dev/MSM89xx/06010/PFAM 上提交代码，就必须首先新建一个本地分支并检出代码
才能工作：

    git branch C5F/dev/MSM89xx/06010/PFAM --track origin/C5F/dev/MSM89xx/06010/PFAM
    git checkout C5F/dev/MSM89xx/06010/PFAM
    
上面两条命令等同于下面一条命令：
    
    git checkout -b C5F/dev/MSM89xx/06010/PFAM --track origin/C5F/dev/MSM89xx/06010/PFAM
    
你的代码是提交在本地分支上的，然后由本地分支推送到远程。

或者有时候你会发现直接执行 `git checkout C5F/dev/MSM89xx/06010/PFAM` 也能工作。这是
因为，当 git 尝试检出 `C5F/dev/MSM89xx/06010/PFAM` 分支时候，发现并没有这样一个本地
分支。此时如果远程跟踪分支有一个这样的分支，git 就执行上面第二种形式的命令。虽然很多时候
这样也能工作，但是不清不楚容易使人迷惑。

origin 和 master
----------------
远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义。同时 
“master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用，“origin” 是
当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的
远程仓库的名字将为 booyah；如果你运行 git clone -b branch-name，那么你默认检出的分支将
为 branch-name，而不是 master。
    
